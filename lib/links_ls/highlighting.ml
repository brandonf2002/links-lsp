(* open Lsp.Types *)
(* open Lsp *)
(* open Document_state *)
(* open Links_core.SourceCode *)
(* open Links_lsp.Common *)

(* let legend : SemanticTokenTypes.t list = *)
(*   [ Type; Variable; Function; Keyword; Comment; String; Number ] *)
(* ;; *)

(* let list = [] *)

(* let tokenTypes : string list = *)
(*   List.map *)
(*     (fun s -> *)
(*       match SemanticTokenTypes.yojson_of_t s with *)
(*       | `String s -> s *)
(*       | _ -> failwith "") *)
(*     legend *)
(* ;; *)

(* let legend = SemanticTokensLegend.create ~tokenTypes ~tokenModifiers:list *)

(* class completion_traversal ~is_temp_item ~has_types = *)
(*   object (self : 'self_type) *)
(*     inherit Links_core.SugarTraversals.fold as super *)

(*     (1* method printer = log_to_file *1) *)
(*     method printer = print_endline *)

(*     method! binding b = *)
(*       let open Links_core.Sugartypes in *)
(*       (match b.node with *)
(*        | Fun f -> *)
(*          (1* self#add_item *1) *)
(*          (1*   (Binder.to_name f.fun_binder) *1) *)
(*          (1*   ~kind:Types.CompletionItemKind.Function *1) *)
(*          (1*   ~detail:(Links_core.Types.string_of_datatype (Binder.to_type f.fun_binder)) *1) *)
(*          () *)
(*        | _ -> ()); *)
(*       super#binding b *)

(*     method! pattern p = *)
(*       let open Links_core.Sugartypes in *)
(*       (match p.node with *)
(*        | Variable v -> () *)
(*        | _ -> ()); *)
(*       super#pattern p *)

(*     method! program p = super#program p *)
(*     method! name n = super#name n *)
(*     method! binder n = super#binder n *)
(*     method! phrasenode p = super#phrasenode p *)
(*   end *)

(* let highlight (p : Types.SemanticTokensParams.t) = *)
(*   let doc = get_document p.textDocument.uri in *)
(*   let parsed_ast, desugared_ast = *)
(*     match doc with *)
(*     | None -> None, None *)
(*     | Some v -> v.parsed_ast, v.desugared_ast *)
(*   in *)
(*   let content = *)
(*     match doc with *)
(*     | None -> "" *)
(*     | Some v -> v.content *)
(*   in *)
(*   `Null *)
(* ;; *)
